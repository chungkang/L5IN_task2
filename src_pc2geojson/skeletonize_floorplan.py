# -*- coding: utf-8 -*-
"""skeletonize_floorplan.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1UPLW8DmBV2UXczAiwKsGr57Y_B47QHfN
"""

# Import the necessary libraries
import cv2
import math
import numpy as np
import matplotlib.pyplot as plt

#Good ref for connecting broken lines: https://stackoverflow.com/questions/63727525/how-to-connect-broken-lines-that-cannot-be-connected-by-erosion-and-dilation?noredirect=1&lq=1
#Mergin of hough transform lines: https://stackoverflow.com/questions/45531074/how-to-merge-lines-after-houghlinesp

class LineBundler:
  '''Clasterize and merge each cluster of cv2.HoughLinesP() output
  a = LineBundler()
  foo = a.process_lines(houghP_lines, binary_image)
  '''

  def get_orientation(self, line):
      '''get orientation of a line, using its length
      https://en.wikipedia.org/wiki/Atan2
      '''
      orientation = math.atan2(abs((line[0] - line[2])), abs((line[1] - line[3])))
      return math.degrees(orientation)

  def checker(self, line_new, groups, min_distance_to_merge, min_angle_to_merge):
      '''Check if line have enough distance and angle to be count as similar
      '''
      for group in groups:
          # walk through existing line groups
          for line_old in group:
              # check distance
              if self.get_distance(line_old, line_new) < min_distance_to_merge:
                  # check the angle between lines
                  orientation_new = self.get_orientation(line_new)
                  orientation_old = self.get_orientation(line_old)
                  # if all is ok -- line is similar to others in group
                  if abs(orientation_new - orientation_old) < min_angle_to_merge:
                      group.append(line_new)
                      return False
      # if it is totally different line
      return True

  def DistancePointLine(self, point, line):
      """Get distance between point and line
      http://local.wasp.uwa.edu.au/~pbourke/geometry/pointline/source.vba
      """
      px, py = point
      x1, y1, x2, y2 = line

      def lineMagnitude(x1, y1, x2, y2):
          'Get line (aka vector) length'
          lineMagnitude = math.sqrt(math.pow((x2 - x1), 2) + math.pow((y2 - y1), 2))
          return lineMagnitude

      LineMag = lineMagnitude(x1, y1, x2, y2)
      if LineMag < 0.00000001:
          DistancePointLine = 9999
          return DistancePointLine

      u1 = (((px - x1) * (x2 - x1)) + ((py - y1) * (y2 - y1)))
      u = u1 / (LineMag * LineMag)

      if (u < 0.00001) or (u > 1):
          #// closest point does not fall within the line segment, take the shorter distance
          #// to an endpoint
          ix = lineMagnitude(px, py, x1, y1)
          iy = lineMagnitude(px, py, x2, y2)
          if ix > iy:
              DistancePointLine = iy
          else:
              DistancePointLine = ix
      else:
          # Intersecting point is on the line, use the formula
          ix = x1 + u * (x2 - x1)
          iy = y1 + u * (y2 - y1)
          DistancePointLine = lineMagnitude(px, py, ix, iy)

      return DistancePointLine

  def get_distance(self, a_line, b_line):
      """Get all possible distances between each dot of two lines and second line
      return the shortest
      """
      dist1 = self.DistancePointLine(a_line[:2], b_line)
      dist2 = self.DistancePointLine(a_line[2:], b_line)
      dist3 = self.DistancePointLine(b_line[:2], a_line)
      dist4 = self.DistancePointLine(b_line[2:], a_line)

      return min(dist1, dist2, dist3, dist4)

  def merge_lines_pipeline_2(self, lines):
      'Clusterize (group) lines'
      groups = []  # all lines groups are here
      # Parameters to play with
      min_distance_to_merge = 30
      min_angle_to_merge = 30
      # first line will create new group every time
      groups.append([lines[0]])
      # if line is different from existing gropus, create a new group
      for line_new in lines[1:]:
          if self.checker(line_new, groups, min_distance_to_merge, min_angle_to_merge):
              groups.append([line_new])

      return groups

  def merge_lines_segments1(self, lines):
      """Sort lines cluster and return first and last coordinates
      """
      orientation = self.get_orientation(lines[0])

      # special case
      if(len(lines) == 1):
          return [lines[0][:2], lines[0][2:]]

      # [[1,2,3,4],[]] to [[1,2],[3,4],[],[]]
      points = []
      for line in lines:
          points.append(line[:2])
          points.append(line[2:])
      # if vertical
      if 45 < orientation < 135:
          #sort by y
          points = sorted(points, key=lambda point: point[1])
      else:
          #sort by x
          points = sorted(points, key=lambda point: point[0])

      # return first and last point in sorted group
      # [[x,y],[x,y]]
      return [points[0], points[-1]]

  def process_lines(self, lines, img):
      '''Main function for lines from cv.HoughLinesP() output merging
      for OpenCV 3
      lines -- cv.HoughLinesP() output
      img -- binary image
      '''
      lines_x = []
      lines_y = []
      # for every line of cv2.HoughLinesP()
      for line_i in [l[0] for l in lines]:
              orientation = self.get_orientation(line_i)
              # if vertical
              if 45 < orientation < 135:
                  lines_y.append(line_i)
              else:
                  lines_x.append(line_i)

      lines_y = sorted(lines_y, key=lambda line: line[1])
      lines_x = sorted(lines_x, key=lambda line: line[0])
      merged_lines_all = []

      # for each cluster in vertical and horizantal lines leave only one line
      for i in [lines_x, lines_y]:
              if len(i) > 0:
                  groups = self.merge_lines_pipeline_2(i)
                  merged_lines = []
                  for group in groups:
                      merged_lines.append(self.merge_lines_segments1(group))

                  merged_lines_all.extend(merged_lines)

      return merged_lines_all

total_lines = []

def FLD(image):
  # Create default Fast Line Detector class
  length_threshold = 2 #default 10
  distance_threshold = 10 #default: 1.41421356 or 50
  
  #These are not really important for us
  canny_th1 = 100.0 #not important
  canny_th2 = 200.0 #not important
  canny_aperture_size =0 # we don't need to apply the canny filter
  do_merge = False

  #Detect lines here
  fld = cv2.ximgproc.createFastLineDetector(length_threshold, distance_threshold, canny_th1, canny_th2, canny_aperture_size, do_merge)

  # Get line vectors from the image
  lines = fld.detect(image)

  for line in lines:
    total_lines.append(line)

  print("Generating final image skeleton")
  # Draw lines on the image
  line_on_image = fld.drawSegments(image, lines)

  cv2.imwrite("skeleton_FLD.png", line_on_image)

def DialteFLD(image):
  kernel = np.ones((5,5),np.uint8)
  dilation = cv2.dilate(image,kernel,iterations = 1)
  print("Generating dialted FLD skeleton image...")
  cv2.imwrite("skeleton_FLD_dialted.png", dilation)

def HoughLineTest(image):
  print("Running Hough Transform P line detector")
  minLineLength = 10
  maxLineGap = 2
  lines = cv2.HoughLinesP(image,1,np.pi/180,10,minLineLength,maxLineGap)

  img_hough_lines = np.zeros(image.shape)

  for line in lines:
    total_lines.append(line)
    cv2.line(img_hough_lines,(line[0][0],line[0][1]),(line[0][2],line[0][3]),(255,0,0),1)

  cv2.imwrite("skeleton_HT.png", img_hough_lines)

def WriteWallCoords(lines):
  print("Generating wall coords...")

  with open('walls_v3.txt', 'a') as f:
    for line in lines:
      #x0, y0 = line[0]
      #x1, y1 = line[1]
      #length = cv2.norm(line[1] - line[0]);
      length = line[1][0] - line[0][0]
      coordinates = str(line[0][0]) + ' ' + str(line[0][1]) + ' ' + str(line[1][0]) + ' ' + str(line[1][1]) +  ' ' + str(length) +'\n'
      f.write(coordinates)
      
    f.close()

# Read the image as a grayscale image
img = cv2.imread('3_sb_morhps_dist_transform_thresh_crop.png', 0) #TODO: Test using dist transform image
#img = cv2.imread('3_sb_morhps_dist_transform_thresh.png', 0)

#Thinning test
thinned_v1 = cv2.ximgproc.thinning(img)

cv2.imwrite("skeleton_THINNED.png", thinned_v1)

#Hough transform tests
#HoughLineTest(thinned_v1)

#FLD tests
FLD(thinned_v1)

#Dialted fld test
#fld_img = cv2.imread('skeleton_FLD.png', 0)
#DialteFLD(fld_img)

#Merge both line sets
img_merged_lines = np.zeros(img.shape)

line_bundler = LineBundler()
bundled_lines = line_bundler.process_lines(total_lines, img_merged_lines)

for line in bundled_lines:
  cv2.line(img_merged_lines, (int(line[0][0]), int(line[0][1])), (int(line[1][0]),int(line[1][1])), (255,0,0), 1)

cv2.imwrite("skeleton_MERGED.png", img_merged_lines)

WriteWallCoords(bundled_lines)