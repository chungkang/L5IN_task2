# -*- coding: utf-8 -*-
"""skeletonize_floorplan_v2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1piQpAxnOzTf6GydOVg4vCkI4fSzt0pLn
"""

# Import the necessary libraries
import cv2
import math
import numpy as np
import matplotlib.pyplot as plt

total_lines = []


def closestDistanceBetweenLines(a0,a1,b0,b1,clampAll=False,clampA0=False,clampA1=False,clampB0=False,clampB1=False):
  ''' Given two lines defined by numpy.array pairs (a0,a1,b0,b1)
      Return the closest points on each segment and their distance
  '''

  # If clampAll=True, set all clamps to True
  if clampAll:
      clampA0=True
      clampA1=True
      clampB0=True
      clampB1=True


  # Calculate denomitator
  A = a1 - a0
  B = b1 - b0
  magA = np.linalg.norm(A)
  magB = np.linalg.norm(B)
  
  _A = A / magA
  _B = B / magB
  
  cross = np.cross(_A, _B);
  denom = np.linalg.norm(cross)**2
  
  
  # If lines are parallel (denom=0) test if lines overlap.
  # If they don't overlap then there is a closest point solution.
  # If they do overlap, there are infinite closest positions, but there is a closest distance
  if not denom:
      d0 = np.dot(_A,(b0-a0))
      
      # Overlap only possible with clamping
      if clampA0 or clampA1 or clampB0 or clampB1:
          d1 = np.dot(_A,(b1-a0))
          
          # Is segment B before A?
          if d0 <= 0 >= d1:
              if clampA0 and clampB1:
                  if np.absolute(d0) < np.absolute(d1):
                      return a0,b0,np.linalg.norm(a0-b0)
                  return a0,b1,np.linalg.norm(a0-b1)
              
              
          # Is segment B after A?
          elif d0 >= magA <= d1:
              if clampA1 and clampB0:
                  if np.absolute(d0) < np.absolute(d1):
                      return a1,b0,np.linalg.norm(a1-b0)
                  return a1,b1,np.linalg.norm(a1-b1)
              
              
      # Segments overlap, return distance between parallel segments
      return None,None,np.linalg.norm(((d0*_A)+a0)-b0)
      
  
  
  # Lines criss-cross: Calculate the projected closest points
  t = (b0 - a0);
  detA = np.linalg.det([t, _B, cross])
  detB = np.linalg.det([t, _A, cross])

  t0 = detA/denom;
  t1 = detB/denom;

  pA = a0 + (_A * t0) # Projected closest point on segment A
  pB = b0 + (_B * t1) # Projected closest point on segment B


  # Clamp projections
  if clampA0 or clampA1 or clampB0 or clampB1:
      if clampA0 and t0 < 0:
          pA = a0
      elif clampA1 and t0 > magA:
          pA = a1
      
      if clampB0 and t1 < 0:
          pB = b0
      elif clampB1 and t1 > magB:
          pB = b1
          
      # Clamp projection A
      if (clampA0 and t0 < 0) or (clampA1 and t0 > magA):
          dot = np.dot(_B,(pA-b0))
          if clampB0 and dot < 0:
              dot = 0
          elif clampB1 and dot > magB:
              dot = magB
          pB = b0 + (_B * dot)
  
      # Clamp projection B
      if (clampB0 and t1 < 0) or (clampB1 and t1 > magB):
          dot = np.dot(_A,(pB-a0))
          if clampA0 and dot < 0:
              dot = 0
          elif clampA1 and dot > magA:
              dot = magA
          pA = a0 + (_A * dot)

  
  return pA,pB,np.linalg.norm(pA-pB)

def FLD(image, name):
  # Create default Fast Line Detector class
  length_threshold = 2 #default 10
  distance_threshold = 10 #default: 1.41421356 or 50
  
  #These are not really important for us
  canny_th1 = 100.0 #not important
  canny_th2 = 200.0 #not important
  canny_aperture_size =0 # we don't need to apply the canny filter
  do_merge = False

  #Detect lines here
  fld = cv2.ximgproc.createFastLineDetector(length_threshold, distance_threshold, canny_th1, canny_th2, canny_aperture_size, do_merge)

  # Get line vectors from the image
  lines = fld.detect(image)

  for line in lines:
    total_lines.append(line)

  print("Generating final image skeleton")
  # Draw lines on the image
  line_on_image = fld.drawSegments(image, lines)

  cv2.imwrite(name, line_on_image)

def WriteWallCoords(lines):
  print("Generating wall coords...")

  with open('walls_v3.txt', 'a') as f:
    for line in lines:
      #x0, y0 = line[0]
      #x1, y1 = line[1]
      #length = cv2.norm(line[1] - line[0]);
      length = 0
      coordinates = str(line[0][0]) + ' ' + str(line[0][1]) + ' ' + str(line[0][2]) + ' ' + str(line[0][3]) +  ' ' + str(length) +'\n'
      f.write(coordinates)
      
    f.close()

# Read the image as a grayscale image
img = cv2.imread('3_sb_morhps_dist_transform_thresh_crop.png', 0) 

#Thinning test
thinned_v1 = cv2.ximgproc.thinning(img)

#cv2.imwrite("skeleton_THINNED.png", thinned_v1)

#FLD pass 1
FLD(thinned_v1, "skeleton_1.png")

fld_image = cv2.imread('skeleton_1.png')

temp_array = []
l = len(total_lines)
for index, lines in enumerate(total_lines):
  if index < (l - 1):
    current_line = total_lines[index]
    next_line = total_lines[index + 1]

    a0 = np.array([current_line[0][0], 0, current_line[0][1]])
    a1 = np.array([current_line[0][2], 0, current_line[0][3]])

    b0 = np.array([next_line[0][0], 0, next_line[0][1]])
    b1 = np.array([next_line[0][2], 0, next_line[0][3]])

    #print(closestDistanceBetweenLines(a0,a1,b0,b1,clampAll=True))
    temp_array.append(closestDistanceBetweenLines(a0,a1,b0,b1,clampA1=True,clampB0=True))

#Now reshape these to 2D and add values to new "snapped lines array"
snapped_lines_array = []
for snapped_line in temp_array:
  snapped_lines_array.append([snapped_line[0][0], snapped_line[0][2], snapped_line[1][0], snapped_line[1][2]])

img_snapped_lines = np.zeros(img.shape)

for line in snapped_lines_array:
  cv2.line(img_snapped_lines,(int(line[0]), int(line[1])), (int(line[2]),int(line[3])),(255,0,0),1)

cv2.imwrite("snapped_lines.png", img_snapped_lines)

#print(snapped_lines_array)

#WriteWallCoords(bundled_lines)

#WriteWallCoords(snapped_lines_array)